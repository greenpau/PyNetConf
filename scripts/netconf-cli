#!/usr/bin/env python

#------------------------------------------------------------------------------------------#
# File:      test.py                                                                       #
# Purpose:   PyNetConf - IETF Network Configuration Protocol Client Library                #
# Author:    Paul Greenberg                                                                #
# Version:   1.0                                                                           #
# Copyright: (c) 2014 Paul Greenberg <paul@greenberg.pro>                                  #
#------------------------------------------------------------------------------------------#

import os;
import stat;
import sys;
if sys.version_info[0] < 3:
    sys.stderr.write(os.path.basename(__file__) + ' requires Python 3 or higher.\n');
    sys.stderr.write("python3 " + __file__ + '\n');
    sys.exit(1);
sys.path.append(os.path.join('/'.join(os.path.abspath(__file__).split('/')[:-2])));
import argparse;
import pprint;
import datetime;
import traceback;
import logging;
import configparser;

logging.basicConfig(format='%(asctime)s - %(name)s - %(funcName)s() - %(levelname)s - %(message)s');
logger = logging.getLogger(__file__);
logger.setLevel(logging.DEBUG);

try:
    from pynetconf import NetConfSession;
except Exception as err:
    for e in err.args:
        logger.error(str(type(err).__name__) + ': ' + str(e));
    sys.exit(1);

def _load_credentials(h):

    logger.info('checking for local credentials ...');

    f = os.path.join(os.environ['HOME'], '.netconf.rc');
    if not os.path.exists(f):
        logger.error('credentials file ' + f + ' does not exist, exiting ...');
        sys.exit(1);
    if not os.path.isfile(f):
        logger.error('credentials file ' + f + ' is not a file, exiting ...');
        sys.exit(1);
    if not os.access(f, os.R_OK):
        logger.error('credentials file ' + f + ' is not readable, exiting ...');
        sys.exit(1);

    print( oct(stat.S_IMODE(os.stat(f).st_mode)))
    if not oct(stat.S_IMODE(os.stat(f).st_mode)) == '0o600':
        logger.error('credentials file ' + f + ' is not secure!');
        logger.error('try running "chmod 600 ' + f + '" to secure it, exiting ...');
        sys.exit(1);

    c = configparser.ConfigParser();
    c.read(f);
    if 'DEFAULT' not in c:
        logger.error('credentials file is missing DEFAULT section, exiting ...');
        sys.exit(1);
    if 'username' not in c['DEFAULT']:
        logger.error('credentials file is missing "username" key in DEFAULT section, exiting ...');
        sys.exit(1);
    if 'password' not in c['DEFAULT'] and 'private_rsa_key' not in c['DEFAULT']:
        logger.error('credentials file is missing either "password" or "private_rsa_key" key in DEFAULT section, exiting ...');
        sys.exit(1);

    return(c['DEFAULT']['username'], c['DEFAULT']['password']);

def main():
    global logger;
    func = 'main()';
    descr = 'PyNetConf - IETF Network Configuration Protocol Client Library\n\n';
    descr += 'examples:\n \n';
    descr += '  python3 ' + str(__file__) + ' -ho router -P 22 -u admin -p cisco -c "show run" -l 3\n \n';
    descr += '  python3 ' + str(__file__) + ' -ho router -u admin -k ~/.ssh/id_rsa \\\n';
    descr += '    --cmd "show interfaces" --cmd "show version" -l 5\n \n';
    descr += '  python3 ' + str(__file__) + ' --help';
    epil = 'documentation:\n  https://github.com/greenpau/PyNetConf\n \n';
    parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter,
                                     description=descr, epilog=epil);
    conn_group = parser.add_argument_group('network connectivity arguments');
    conn_group.add_argument('-ho', '--host', dest='ihost', metavar='HOST', 
                            type=str, required=True, help='host IP or DNS Name');
    conn_group.add_argument('-P', '--port', dest='iport', metavar='PORT', 
                            type=int, default=22, help='tcp port (default: 22)');
    auth_group = parser.add_argument_group('authentication arguments')
    auth_group.add_argument('-u', '--user', dest='iuser', metavar='USERNAME', 
                            type=str, help='username');
    credgroup = auth_group.add_mutually_exclusive_group();
    credgroup.add_argument('-p', '--pass', dest='ipass', metavar='PASSWORD', 
                           type=str, help='password');
    credgroup.add_argument('-k', '--key', dest='ipass', metavar='SSH_KEY_FILE_PATH', 
                           type=argparse.FileType('r'), help='SSH private key file path');
    cmd_group = parser.add_argument_group('directives');
    cmd_group.add_argument('-c', '--cmd', dest='icmd', metavar='COMMAND', action='append', 
                           type=str, required=True, help='commands');
    auth_group.add_argument('--check-fingerprint', dest='ifc', action='store_true', 
                            help='enable SSH fingerprint check');
    parser.add_argument('-l', '--log-level', dest='ilog', metavar='LEVEL', type=int, 
                        default=0, choices=range(1, 4), help='log level (default: 0)');
    args = parser.parse_args();
 
    if args.ilog == 1:
        logger.setLevel(logging.WARN);
    elif args.ilog == 2:
        logger.setLevel(logging.INFO);
    elif args.ilog == 3:
        logger.setLevel(logging.DEBUG);
    else:
        logger.setLevel(logging.ERROR);

    if args.iuser and args.ipass:
        iuser = args.iuser;
        ipass = args.ipass;
    else:
        iuser, ipass = _load_credentials(args.ihost);

    try:
        logger.info('building a NETCONF session to ' + args.ihost + ' over TCP port ' + str(args.iport) + ' ...');
        nc = NetConfSession(args.ihost, iuser, ipass, args.iport, args.ifc, args.ilog);
        if nc.error:
            logger.error('failed to prepare for a NETCONF session to ' + args.ihost + ' over TCP port ' + str(args.iport));
            sys.exit(1);
        nc.connect();
        if nc.error:
            logger.error('failed to establish a NETCONF session to ' + args.ihost + ' over TCP port ' + str(args.iport));
            sys.exit(1);
        logger.info('connected to ' + args.ihost + ' over TCP port ' + str(args.iport) + ' for a NETCONF session');

        ''' display client and server capabilities '''
        nc.show('capabilities', 'client');  # alternatively, pprint.pprint(nc.capabilities['client']);
        nc.show('capabilities', 'server');  # alternatively, pprint.pprint(nc.capabilities['server']);

        for c in args.icmd:            
            nc.cmd(c);
            if nc.error:
                logger.error('failed to execute "' + c +'" command on ' + args.ihost);
                sys.exit(1);
            logger.info(str(nc.resp));

        nc.close();
        if nc.error:
            logger.error('failed to graceful disconnect a NETCONF session to ' + args.ihost + ' over TCP port ' + str(args.iport));
            sys.exit(1);

    except Exception as err:
        for e in err.args:
            logger.error(str(type(err).__name__) + ': ' + str(e));
        for i in str(traceback.format_exc()).splitlines():
            logger.error(str(type(err).__name__) + ': ' + str(i));
        return;
    
    sys.exit(0);

if __name__ == '__main__':
    main();
